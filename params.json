{
  "name": "Vitamin",
  "tagline": "Data Mapper library for Node.js applications",
  "body": "## Introduction\r\nVitamin provides a simple and easy to use Data Mapper implementation for working with your relational database.\r\n\r\nBased on [knex](//knexjs.org), it supports **Postgres**, **MySQL**, **MariaDB**, **SQLite3**, and **Oracle** databases, \r\nfeaturing both promise based and traditional callback interfaces, providing lazy and eager relationships loading, \r\nand support for one-to-one, one-to-many, and many-to-many relations.\r\n\r\n***\r\n\r\n## Installation\r\n```\r\n$ npm install --save vitamin\r\n\r\n# Then add one of the supported database drivers\r\n$ npm install pg\r\n$ npm install sqlite3\r\n$ npm install mysql\r\n$ npm install mysql2\r\n$ npm install mariasql\r\n$ npm install strong-oracle\r\n$ npm install oracle\r\n```\r\n\r\nVitamin is initialized by passing an initialized Knex client instance. \r\nThe [knex documentation](//knexjs.org/#Installation) provides a number of examples for different use cases.\r\n\r\n```js\r\nvar knex = require('knex')({\r\n  client: 'mysql',\r\n  connection: {\r\n    host     : '127.0.0.1',\r\n    user     : 'your_database_user',\r\n    password : 'your_database_password',\r\n    database : 'your_database_name',\r\n    charset  : 'utf8'\r\n  }\r\n})\r\n\r\nmodule.exports = require('vitamin')(knex)\r\n```\r\n***\r\n\r\n## Getting started\r\n\r\n### Defining data mappers\r\n\r\nTo get started, let's define a user data mapper by specifying both, the `primary key` name, and the `table` name\r\n\r\n```js\r\n// using the previous initialized vitamin object,\r\n// we define a mapper called `user` using `mapper` method of vitamin object\r\nmodule.exports = vitamin.model('user', {\r\n  \r\n  // the primary key, default to `id`\r\n  primaryKey: 'user_id',\r\n  \r\n  // the table name\r\n  tableName: 'users',\r\n  \r\n  // add default attributes\r\n  defaults: {\r\n    active: true,\r\n    verified: false\r\n  }\r\n  \r\n})\r\n```\r\n> `model()` also accepts a mapper instance passed as a second argument instead of a config object\r\n\r\n### CRUD : Reading and writing data\r\n\r\n> You can use the standard Node.js style callbacks by calling `.asCallback(function (error, result) {})` on any promise method\r\n\r\n#### 1 - Create\r\nTo create a new record in the database, simply create a new model instance, set its attributes, then call the `save` method\r\n```js\r\n// access the model generated by the mapper via vitamin's `model` method\r\nvar User = vitamin.model('user')\r\n\r\n// we create a new instance of User model with `make` method\r\nvar user = User.make({ name: \"John\", occupation: \"Developer\" })\r\n// or simply with the new operator\r\nvar user = new User({ name: \"John\", occupation: \"Developer\" })\r\n\r\n// then we save it\r\nuser.save()\r\n.then(function (result) {\r\n  assert.equal(result, user)\r\n  assert.instanceOf(result, User)\r\n})\r\n.catch(function (error) {\r\n  ...\r\n})\r\n```\r\nAnother shorthand to create and save a new user is the `create` static method\r\n\r\n```js\r\nvar data = { name: \"John\", occupation: \"Developer\" }\r\n\r\nUser.create(data).then(function (result) {\r\n  assert.instanceOf(result, User)\r\n})\r\n```\r\n\r\n#### 2 - Read\r\n\r\nBelow a few examples of different data access methods provided by Vitamin.\r\n\r\n* Retrieving multiple models\r\n\r\n```js\r\n// get a collection of all users\r\nUser.query().fetch().then(\r\n  function (result) {\r\n    assert.instanceOf(result, Collection)\r\n  },\r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n```\r\nThe `fetch` method will return all the rows in the `users` table as a collection of `User` models. \r\nBut, if you may also add constraints to queries, you can use the `where` method, which returns a `query builder` instance\r\n\r\n```js\r\nUser.query().where('role', \"guest\").offset(10).limit(15).fetch().then(\r\n  function (result) {\r\n    assert.instanceOf(result, Collection)\r\n  },\r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n```\r\n\r\n* Retrieving single model\r\nOf course, in addition to retrieving all of the records for a given table, you may also retrieve single records using `find` and `first`.\r\nInstead of returning a collection of models, these methods return only a single model instance\r\n\r\n```js\r\n// find a user by its primary key\r\nUser.query().find(123).then(\r\n  function (result) {\r\n    assert.instanceOf(result, User)\r\n  },\r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n```\r\nTo retrieve the first model matching the query constraints, use `first`\r\n\r\n```js\r\n// fetch the `id` and `email` of the first admin user\r\nUser.query().where('is_admin', true).first('id', 'email').then(\r\n  function (result) {\r\n    assert.instanceOf(result, User)\r\n  },\r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n```\r\n\r\n#### 3 - Update\r\nThe `save` method may also be used to update a single model that already exists in the database.\r\nTo update a model, you should retrieve it, set any attributes you wish to update, and then call the `save` method.  \r\n```js\r\n// post model is retrieved from `posts` table\r\n// then we modify the status attribute and save it\r\nvar Post = vitamin.model('post')\r\n\r\nPost.query().find(1).then(function (post) {\r\n  return post.set('status', \"draft\").save()\r\n})\r\n```\r\nIn case you have many attributes to edit, you may use the `update` method directly:\r\n```js\r\nvar data = { 'status': \"published\", 'published_at': new Date }\r\n\r\npost.update(data).then(\r\n  function (result) {\r\n    ...\r\n  },\r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n```\r\n\r\n#### 4 - Delete\r\nLikewise, once retrieved, a model can be destroyed which removes it from the database.\r\nTo delete a model, call the `destroy` method on an existing model instance:\r\n```js\r\nPost.make({ id : 45 }).destroy().then(\r\n  function (result) {\r\n    assert.equal(result, post)\r\n  },\r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n```\r\nOf course, you may also run a delete query on a set of models.\r\n```js\r\n// we will delete all posts that are marked as draft\r\nPost.query().where('status', 'draft').destroy().then(\r\n  function (result) {\r\n    ...\r\n  },\r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n```\r\n\r\n### Events\r\nModel events allow you to attach code to certain events in the lifecycle of yours models. \r\nThis enables you to add behaviors to your models when those built-in events \r\n`ready`, `creating`, `created`, `saving`, `saved`, `updating`, `updated`, `deleting` or `deleted` occur.\r\n\r\nEvents can be defined when you register the model\r\n```js\r\nvitamin.model('user', {\r\n  \r\n  ...\r\n  \r\n  events: {\r\n    \r\n    'creating': _.noop,\r\n    \r\n    'saved': [\r\n      handler1,\r\n      handler2,\r\n    ]\r\n  }\r\n  \r\n})\r\n```\r\nOr, later with the static method `on`\r\n```js\r\n// attach a listener for `created` event\r\nUser.on('created', function (user) {\r\n  assert.instanceOf(user, User)\r\n})\r\n\r\n// Events `saving - creating - created - saved` are fired in order when we create a new model\r\n>>> User.create({ name: \"John\", occupation: \"Developer\" })\r\n```\r\nYou can also attach the same handler for many events separated by a white space\r\n```js\r\nPost.on('creating updating', updateTimestamps)\r\n```\r\nThe built-in events are fired automatically by the mapper, but you can trigger manually those events, or any custom ones\r\n\r\n```js\r\nPost.make().emit('saving')\r\n\r\nOrder.make().emit('purchased', ...arguments)\r\n```\r\n***\r\n\r\n## Associations\r\nVitamin makes managing and working with relationships easy, and supports several types of relations:\r\n\r\n* One To One\r\n* One To Many\r\n* Many To Many\r\n\r\n### Defining relations\r\n\r\n#### One to One\r\n\r\nLet's define a relation one to one between `Person` and `Phone`.\r\n```js\r\nvar Phone = vitamin.model('phone', {\r\n  \r\n  tableName: 'phones',\r\n  \r\n  relations: {\r\n    \r\n    owner: function () {\r\n      // we refer to`Person` mapper by its name\r\n      // `owner_id` is the foreign key of `users` in `phones` table\r\n      return this.belongsTo('person', 'owner_id', 'id')\r\n    }\r\n    \r\n  }\r\n  \r\n})\r\n\r\nvar Person = vitamin.model('person', {\r\n  \r\n  tableName: 'people',\r\n  \r\n  relations: {\r\n    \r\n    phone: function () {\r\n      // the first argument is the target mapper name\r\n      // the second is the foreign key in phones table\r\n      // the third parameter is optional, it corresponds to the primary key of person model\r\n      return this.hasOne('phone', 'owner_id', 'id')\r\n    }\r\n    \r\n  }\r\n  \r\n})\r\n```\r\n\r\n#### One To Many\r\n\r\nAn example for this type, is the relation between blog `post` and its `author`\r\n```js\r\nvar User = vitamin.model('user', {\r\n  \r\n  tableName: 'users',\r\n  \r\n  relations: {\r\n    \r\n    posts: function () {\r\n      // if the foreign key is not provided, \r\n      // vitamin will use the parent mapper name suffixed by '_id',\r\n      // as a foreign key in the `posts` table, in this case `author_id`\r\n      return this.hasMany('post')\r\n    }\r\n    \r\n  }\r\n  \r\n})\r\n\r\nvar Post = vitamin.model('post', {\r\n  \r\n  tableName: 'posts',\r\n  \r\n  relations: {\r\n    \r\n    author: function () {\r\n      return this.belongsTo('author', 'author_id')\r\n    }\r\n    \r\n  }\r\n  \r\n})\r\n```\r\n\r\n#### Many To Many\r\n\r\nThis relation is more complicated than the previous. \r\nAn example of that is the relation between `Product` and `Category`, when a product has many categories, and the same category is assigned to many products. \r\nA pivot table `product_categories` is used and contains the relative keys `product_id` and `category_id`\r\n```js\r\nvitamin.model('product', {\r\n  \r\n  tableName: 'products',\r\n  \r\n  relations: {\r\n    \r\n    categories: function () {\r\n      return belongsToMany('category', 'product_categories', 'category_id', 'product_id')\r\n    }\r\n    \r\n  }\r\n  \r\n})\r\n\r\nvitamin.model('category', {\r\n  \r\n  tableName: 'categories',\r\n  \r\n  relations: {\r\n    \r\n    products: function () {\r\n      return belongsToMany('product', 'product_categories', 'product_id', 'category_id')\r\n    }\r\n    \r\n  }\r\n  \r\n})\r\n```\r\n\r\n### Querying relations\r\n\r\n#### Lazy loading\r\n\r\nWe will use the relations defined below, to lazy load the related models\r\n```js\r\n// load the related phone model of the person with the id 123\r\n// we access the relation via `phone()` which return a HasOne relation instance\r\nvar person = Person.make({ id: 123 })\r\n\r\nperson.load(['posts']).then(function (model) {\r\n  assert.equal(model, person)\r\n  assert.instanceOf(person.getRelated('posts'), Collection)\r\n})\r\n```\r\n\r\n#### Eager loading\r\n\r\nTo load a model and its relationships in one call, you can use the query method `withRelated`\r\n```js\r\n// fetch the first article and its author\r\nPost.query().withRelated('author').first().then(function (post) {\r\n  assert.instanceOf(post.getRelated('author'), User)\r\n})\r\n\r\n// load all authors with their posts\r\nUser.query().withRelated('posts').fetch().asCallback((error, authors) => {\r\n  assert.instanceOf(authors, Collection)\r\n  \r\n  authors.forEach(function (author) {\r\n    assert.instanceOf(author.getRelated('posts'), Collection)\r\n    assert.instanceOf(author.getRelated('posts').first(), Post)\r\n  })\r\n})\r\n```\r\n\r\n### Saving related models\r\n\r\nInstead of manually setting the foreign keys, Vitamin provides many methods to save the related models.\r\n\r\n#### `save()` and `saveMany()`\r\n\r\n```js\r\nvar comment = Comment.make({ body: \"Hello World !!\" })\r\n\r\n// saving and attach one comment\r\npost.comments().save(comment).then(\r\n  function (model) {\r\n    assert.equal(model, comment)\r\n  },\r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n\r\n// saving many events\r\npost.comments().saveMany([\r\n  Comment.make({ body: \"first comment\" }),\r\n  Comment.make({ body: \"second comment\" })\r\n]).then(function (result) {\r\n  assert.instanceOf(result, Collection)\r\n  assert.instanceOf(result.first(), Comment)\r\n})\r\n```\r\n\r\n#### `create()` and `createMany()`\r\n\r\nIn addition to the `save` and `saveMany` methods, you may also use the `create` method, \r\nwhich accepts an array of attributes, creates a model, and inserts it into the database.\r\n\r\n```js\r\n// create and attach a post comment\r\npost.comments().create({ body: \"Hello World !!\" }).then(function (error, model) {\r\n  assert.instanceOf(model, Comment)\r\n})\r\n\r\n// create and attach the post comments\r\npost.comments().createMany([\r\n  { body: \"first comment\" }, { body: \"second comment\" }\r\n]).then(function (result) {\r\n  assert.instanceOf(result, Collection)\r\n  assert.instanceOf(result.first(), Comment)\r\n})\r\n```\r\n\r\n#### `associate()` and `dissociate()`\r\nWhen updating a `belongsTo` relationship, you may use the `associate` method.\r\n\r\n```js\r\nvar john = Person.make({ id: 123 })\r\n\r\n// set the foreign key `owner_id` and save the phone model\r\nphone.owner().associate(john).save().then(...)\r\n\r\n// unset the foreign key, then save\r\nphone.owner().dissociate().save().then(...)\r\n```\r\n\r\n#### `attach()`, `detach()` and `updatePivot()`\r\nWhen working with many-to-many relationships, Vitamin provides a few additional helper methods to make working with related models more convenient.\r\n\r\n```js\r\n// to attach a role to a user by inserting a record in the joining table\r\nuser.roles().attach(roleId).then(\r\n  function (result) {\r\n    ...\r\n  },\r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n```\r\n\r\nTo remove a many-to-many relationship record, use the detach method.\r\n\r\n```js\r\n// detach all roles of the loaded user\r\nuser.roles().detach().asCallback(function (error, result) {\r\n  ...\r\n})\r\n\r\n// detach only the role with the given id\r\nuser.roles().detach(roleId).then(...)\r\n\r\n// detach all roles with the given ids\r\nuser.roles().detach([1, 2, 3]).then(...)\r\n```\r\n\r\nIf you need to update an existing row in your pivot table, you may use `updatePivot` method\r\n\r\n```js\r\nuser.roles().updatePivot(roleId, pivotAttributes).then(...)\r\n```\r\n\r\n#### `sync()`\r\n\r\nYou may also use the `sync` method to construct many-to-many associations. \r\nThe sync method accepts an array of IDs to place on the intermediate table. \r\nAny IDs that are not in the given array will be removed from the intermediate table. \r\nSo, after this operation is complete, only the IDs in the array will exist in the intermediate table:\r\n\r\n```js\r\n// using callbacks\r\nuser.roles().sync([1, 2, 3], function (error, result) {\r\n  ...\r\n})\r\n\r\n// using promises\r\nuser.roles().sync([1, 2, 3]).then(...)\r\n```\r\nYou may also pass additional intermediate table values with the IDs:\r\n```js\r\nuser.roles().sync([[1, { 'expires': true }], 2]).then(...)\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}