{
  "name": "Vitamin",
  "tagline": "ActiveRecord library for Node.js applications",
  "body": "## Introduction\r\nVitamin provides a simple and easy to use ActiveRecord implementation for working with your database. \r\nEach table or view is wrapped into a \"Model\" class. Thus, a model instance is tied to a single row in the table. \r\nModels allow you to query for data in your tables, as well as inserting or updating records.\r\n\r\nBased on [knex](//knexjs.org), it supports **Postgres**, **MySQL**, **MariaDB**, **SQLite3**, and **Oracle** databases, \r\nfeaturing both promise based and traditional callback interfaces, providing lazy and eager relationships loading, \r\nand support for one-to-one, one-to-many, and many-to-many relations.\r\n\r\n***\r\n\r\n## Installation\r\n```\r\n$ npm install --save vitamin\r\n\r\n# Then add one of the supported database drivers\r\n$ npm install pg\r\n$ npm install sqlite3\r\n$ npm install mysql\r\n$ npm install mysql2\r\n$ npm install mariasql\r\n$ npm install strong-oracle\r\n$ npm install oracle\r\n```\r\n\r\nDatabase connection is initialized by passing a config object to `connection` static method. \r\nThe [knex documentation](//knexjs.org/#Installation) provides a number of examples for different use cases.\r\n\r\n```js\r\nvar Model = require('vitamin')\r\n\r\n// An example of config object for MySQL which will be used by knex\r\nModel.connection({\r\n  client: 'mysql',\r\n  connection: {\r\n    host     : '127.0.0.1',\r\n    user     : 'your_database_user',\r\n    password : 'your_database_password',\r\n    database : 'myapp_test',\r\n    charset  : 'utf8'\r\n  }\r\n})\r\n```\r\n***\r\n\r\n## Examples of usage\r\n\r\n### Defining models\r\nTo get started, let's define a basic Model using the `extend` static method, \r\nand specify both, the `primary key` name, and the `table` name\r\n\r\n```js\r\nvar Model = require('vitamin')\r\n\r\nvar User = Model.extend({\r\n  \r\n  // the primary key, defaults to `id`\r\n  $pk: 'id',\r\n  \r\n  // the table name\r\n  $table: 'users',\r\n  \r\n  // add default attributes\r\n  $defaults: {\r\n    active: true,\r\n    verified: false\r\n  },\r\n  \r\n  // define the mass assignable attributes\r\n  $fillable: [ 'name', 'email', 'password' ],\r\n  \r\n  // define the hidden fields from `toJSON()`\r\n  $hidden: [ 'password' ]\r\n  \r\n})\r\n```\r\n> Vitamin assumes that the primary key is an auto-increment key, if you wish to use a non-numeric key, \r\nyou must set to `false` the flag property `$incrementing` when you define the model.\r\n\r\n### CRUD : Reading and writing data\r\n\r\n#### 1 - Create\r\nTo create a new record in the database, simply create a new model instance, set its attributes, then call the `save` method\r\n```js\r\n// we create a new instance of User model with `factory` method\r\nvar user = User.factory({ name: \"John\", occupation: \"Developer\" })\r\n\r\n// or set the attributes manually after instantiation\r\nvar user = new User\r\nuser.set('name', \"John\")\r\nuser.set('occupation', \"Developer\")\r\n\r\n// then we save it\r\n\r\n// using callbacks\r\nuser.save(function (error, result) {\r\n  assert.instanceOf(result, User)\r\n})\r\n\r\n// or using promises\r\nuser.save().then(\r\n  function (result) {\r\n    assert.instanceOf(result, User)\r\n  },\r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n```\r\nAnother shorthand to create and save a new user is the `create` static method\r\n```js\r\nvar data = { name: \"John\", occupation: \"Developer\" }\r\n\r\n// using callabcks\r\nUser.create(data, function (error, result) {\r\n  assert.instanceOf(result, User)\r\n})\r\n\r\n// using promises\r\nUser.create(data).then(\r\n  function (result) {\r\n    assert.instanceOf(result, User)\r\n  }, \r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n```\r\n\r\n#### 2 - Read\r\n\r\nVitamin uses the standard Node.js style callbacks and promises when dealing with queries.\r\nBelow a few examples of different data access methods provided by Vitamin.\r\n\r\n* Retrieving multiple models\r\n\r\n```js\r\n// get na array of all users \r\n\r\n// using callbacks\r\nUser.all(function (error, result) {\r\n  assert.instanceOf(result, Collection)\r\n})\r\n\r\n// using promises\r\nUser.all().then(\r\n  function (result) {\r\n    assert.instanceOf(result, Collection)\r\n  },\r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n```\r\nThe `all` static method will return all of the results of the model. \r\nBut, if you may also add constraints to queries, you can use the `where` method, which returns a `query builder` instance\r\n\r\n```js\r\n// using callbacks\r\nUser.where('role', \"guest\").offset(10).limit(15).fetchAll(function (error, result) {\r\n  assert.instanceOf(result, Collection)\r\n})\r\n\r\n// using promises\r\nUser.where('role', \"guest\").orderBy('name').fetchAll().then(\r\n  function (result) {\r\n    assert.instanceOf(result, Collection)\r\n  },\r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n```\r\n\r\n* Retrieving single model\r\nOf course, in addition to retrieving all of the records for a given table, you may also retrieve single records using `find` and `fetch`.\r\nInstead of returning an array of models, these methods return only a single model instance\r\n\r\n```js\r\n// find a user by its primary key\r\n\r\n// using callbacks\r\nUser.find(123, function (error, result) {\r\n  assert.instanceOf(result, User)\r\n})\r\n\r\n// using promises\r\nUser.find(123).then(\r\n  function (result) {\r\n    assert.instanceOf(result, User)\r\n  },\r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n```\r\nTo retrieve the first model matching the query constraints, use `fetch`\r\n\r\n```js\r\n// using callbacks\r\nUser.where('is_admin', true).fetch(function (error, result) {\r\n  assert.instanceOf(result, User)\r\n})\r\n\r\n// using promises\r\nUser.where('name', '!=', 'John').fetch().then(\r\n  function (result) {\r\n    assert.instanceOf(result, User)\r\n  },\r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n```\r\n\r\n#### 3 - Update\r\nThe `save` method may also be used to update a single model that already exists in the database.\r\nTo update a model, you should retrieve it, set any attributes you wish to update, and then call the `save` method.  \r\n```js\r\n// post model is retrieved from `posts` table\r\n// then we modify the status attribute and save it\r\nPost\r\n  .find(1)\r\n  .then(function (post) {\r\n    return post.set('status', \"draft\").save()\r\n  })\r\n```\r\nIn case you have many attributes to edit, you may use the `update` method:\r\n```js\r\nvar data = {\r\n  'status': \"published\",\r\n  'published_at': new Date\r\n}\r\n\r\n// Using callbacks\r\npost.update(data, function (error, result) {\r\n  ...\r\n})\r\n\r\n// Using promises\r\npost.update(data).then(\r\n  function (result) {\r\n    ...\r\n  },\r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n```\r\n\r\n#### 4 - Delete\r\nLikewise, once retrieved, a model can be destroyed which removes it from the database.\r\nTo delete a model, call the `destroy` method on an existing model instance:\r\n```js\r\n// Using callbacks\r\npost.destroy(function (error, result) {\r\n  assert.equal(result, post)\r\n})\r\n\r\n// Using promises\r\npost.destroy().then(\r\n  function (result) {\r\n    assert.equal(result, post)\r\n  },\r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n```\r\nOf course, you may also run a delete query on a set of models. In this example, we will delete all posts that are marked as draft:\r\n```js\r\n// Using callbacks\r\nPost.where('status', 'draft').destroy(function (error, result) {\r\n  ...\r\n})\r\n\r\n// Using promises\r\nPost.where('status', 'draft').destroy().then(\r\n  function (result) {\r\n    ...\r\n  },\r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n```\r\n\r\n### Events\r\nModel events allow you to attach code to certain events in the lifecycle of yours models. \r\nThis enables you to add behaviors to your models when those events \r\n`ready`, `creating`, `created`, `saving`, `saved`, `updating`, `updated`, `deleting` or `deleted` occur.\r\n\r\n```js\r\n// attach a listener for `created` event\r\nUser.on('created', function (user) {\r\n  assert.instanceOf(user, Model)\r\n})\r\n\r\n// Events `saving - creating - created - saved` are fired in order\r\n// when we create a new model\r\nUser.create({ name: \"John\", occupation: \"Developer\" })\r\n```\r\nYou can also attach the same handler for many events separated by a white space\r\n```js\r\nPost.on('creating updating', updateTimestamps)\r\n```\r\n***\r\n\r\n## Associations\r\nVitamin makes managing and working with relationships easy, and supports several types of relations:\r\n\r\n* One To One\r\n* One To Many\r\n* Many To Many\r\n\r\n### Defining relations\r\n\r\n#### One to One\r\n\r\nLet's define a relation one to one between `Person` model and `Phone` model\r\n```js\r\nvar Phone = Model.extend({\r\n  \r\n  $table: 'phones',\r\n  \r\n  owner: function () {\r\n    // `user_id` is the foreign key of `users` in `phones` table\r\n    return this.belongsTo(Person, 'owner_id')\r\n  }\r\n  \r\n})\r\n\r\nvar Person = Model.extend({\r\n  \r\n  $table: 'people',\r\n  \r\n  phone: function () {\r\n    // the  first argument is the target model\r\n    // the second is the foreign key in phones table\r\n    // the third parameter is optional, it corresponds to the primary key of person model\r\n    return this.hasOne(Phone, 'owner_id')\r\n  }\r\n})\r\n```\r\n\r\n#### One To Many\r\n\r\nAn example for this type, is the relation between blog `Post` and its `Author`\r\n```js\r\nvar Author = Model.extend({\r\n  \r\n  $table: 'authors',\r\n  \r\n  articles: function () {\r\n    return this.hasMany(Post, 'author_id')\r\n  }\r\n  \r\n})\r\n\r\nvar Post = Model.extend({\r\n  \r\n  $table: 'posts',\r\n  \r\n  author: function () {\r\n    return this.belongsTo(Author, 'author_id')\r\n  }\r\n  \r\n})\r\n```\r\n\r\n#### Many To Many\r\n\r\nthis relation is more complicated than the previous. \r\nAn example of that is the relation between `Product` and `Category`, when a product has many categories, and the same category is assigned to many products. \r\nA pivot table, in this case `product_categories`, is used and contains the relative keys `product_id` and `category_id`\r\n```js\r\nvar Product = Model.extend({\r\n  \r\n  $table: 'products',\r\n  \r\n  categories: function () {\r\n    return belongsToMany(Category, 'product_categories', 'category_id', 'product_id')\r\n  }\r\n  \r\n})\r\n\r\nvar Category = Model.extend({\r\n  \r\n  $table: 'categories',\r\n  \r\n  products: function () {\r\n    return belongsToMany(Product, 'product_categories', 'product_id', 'category_id')\r\n  }\r\n  \r\n})\r\n```\r\n\r\n### Querying relations\r\n\r\n#### Lazy loading\r\n\r\nWe will use the relations defined below, to lazy load the related model\r\n```js\r\n// load the related phone model of the person with the id 123\r\n// we access the relation via `phone()` which return a HasOne relation instance\r\nperson.load(['phone'], function (error, model) {\r\n  assert.equal(person, model)\r\n  assert.instanceOf(model.related('phone'), Phone)\r\n})\r\n\r\n// the same can be done to retrieve all the  author's posts\r\nauthor.load(['posts']).then(function (model) {\r\n  assert.equal(author, model)\r\n  assert.instanceOf(model.related('posts'), Collection)\r\n})\r\n```\r\n\r\n#### Eager loading\r\n\r\nTo load a model and its relationships in one call, you can use the static method `populate`\r\n```js\r\n// fetch the first article and its author\r\nPost.populate('author').fetch().then(function (post) {\r\n  assert.instanceOf(post.related('author'), Author)\r\n})\r\n\r\n// load all authors with their 3 first posts\r\nAuthor\r\n  .populate({ posts: function (query) { query.limit(3) } })\r\n  .fetchAll(function (error, authors) {\r\n    authors.forEach(function (author) {\r\n      assert.instanceOf(author.related('posts'), Collection)\r\n      assert.instanceOf(author.related('posts').first(), Post)\r\n    })\r\n  })\r\n```\r\n\r\n### Saving related models\r\n\r\nInstead of manually setting the foreign keys, Vitamin provides many methods to save the related models.\r\n\r\n#### `save()` and `saveMany()`\r\n\r\n```js\r\nvar comment = Comment.factory({ body: \"Hello World !!\" })\r\n\r\n// using callbacks\r\npost.comments().save(comment, function (error, model) {\r\n  assert.equal(model, comment)\r\n})\r\n\r\n// using promises\r\npost.comments().save(comment).then(\r\n  function (model) {\r\n    assert.equal(model, comment)\r\n  },\r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n```\r\n\r\n```js\r\n// save many using callbacks\r\npost.comments().saveMany([\r\n  Comment.factory({ body: \"first comment\" }),\r\n  Comment.factory({ body: \"second comment\" })\r\n], function (error, result) {\r\n  assert.instanceOf(result, Collection)\r\n  assert.instanceOf(result.first(), Comment)\r\n})\r\n\r\n// using promises\r\npost.comments().saveMany([\r\n  Comment.factory({ body: \"first comment\" }),\r\n  Comment.factory({ body: \"second comment\" })\r\n]).then(function (result) {\r\n  assert.instanceOf(result, Collection)\r\n  assert.instanceOf(result.first(), Comment)\r\n})\r\n```\r\n\r\n#### `create()` and `createMany()`\r\n\r\nIn addition to the `save` and `saveMany` methods, you may also use the `create` method, \r\nwhich accepts an array of attributes, creates a model, and inserts it into the database.\r\n\r\n```js\r\npost.comments().create(, function (error, model) {\r\n  assert.instanceOf(model, Comment)\r\n})\r\n\r\npost.comments().createMany([\r\n  { body: \"first comment\" }, { body: \"second comment\" }\r\n]).then(function (result) {\r\n  assert.instanceOf(result, Collection)\r\n  assert.instanceOf(result.first(), Comment)\r\n})\r\n```\r\n\r\n#### `associate()` and `dissociate()`\r\n\r\nWhen updating a `belongsTo` relationship, you may use the `associate` method.\r\n\r\n```js\r\nvar john = Person.factory({ id: 123 })\r\n\r\n// set the foreign key `owner_id` and save the phone model\r\nphone.owner().associate(john).save()\r\n\r\n// unset the foreign key, then save\r\nphone.owner().dissociate().save()\r\n```\r\n\r\n#### `attach()`, `detach()` and `updatePivot()`\r\n\r\nWhen working with many-to-many relationships, Vitamin provides a few additional helper methods to make working with related models more convenient.\r\n\r\n```js\r\n// to attach a role to a user by inserting a record in the joining table\r\n// using callbacks\r\nuser.roles().attach(roleId, function (error, result) {\r\n  ...\r\n})\r\n\r\n// or using promises\r\nuser.roles().attach(roleId).then(\r\n  function (result) {\r\n    ...\r\n  },\r\n  function (error) {\r\n    ...\r\n  }\r\n)\r\n```\r\n\r\nTo remove a many-to-many relationship record, use the detach method.\r\n\r\n```js\r\n// detach all roles of the loaded user\r\nuser.roles().detach(function (error, result) {\r\n  ...\r\n})\r\n\r\n// detach only the role with the given id\r\nuser.roles().detach(roleId).then(...)\r\n\r\n// detach all roles with the given ids\r\nuser.roles().detach([1, 2, 3]).then(...)\r\n```\r\n\r\nIf you need to update an existing row in your pivot table, you may use `updatePivot` method\r\n\r\n```js\r\nuser.roles().updatePivot(roleId, pivotAttributes).then(...)\r\n```\r\n\r\n#### `sync()`\r\n\r\nYou may also use the `sync` method to construct many-to-many associations. \r\nThe sync method accepts an array of IDs to place on the intermediate table. \r\nAny IDs that are not in the given array will be removed from the intermediate table. \r\nSo, after this operation is complete, only the IDs in the array will exist in the intermediate table:\r\n\r\n```js\r\n// using callbacks\r\nuser.roles().sync([1, 2, 3], function (error, result) {\r\n  ...\r\n})\r\n\r\n// using promises\r\nuser.roles().sync([1, 2, 3]).then(...)\r\n```\r\nYou may also pass additional intermediate table values with the IDs:\r\n```js\r\nuser.roles().sync([{ 1: { 'expires': true } }, 2]).then(...)\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}